# Some Disassembly Required

### x) Read/watch/listen and summarize.

### Hammond 2022: Ghidra for reverse engineering(PicoCTF 2022 #42 'bbbloat'

This video is a tutorial where the presenter uses GHIDRA to solve a specific reverse-engineering challenge.
GHIDRA helps you analyze compiled programs by decompiling and inspecting their structure to figure out what they do.

- Topic: Reverse engineering a CTF (capture the flag) challenge called "bloat" using Ghidra.
- Goal of the video: Solve the PicoCTF "bloat" bianry challenge by unpacking the executable and figuring out how it works.
- The creator walks through loading a binary into Ghidra.
- Examine functions, strings and control flow to understand the program's logic.
- The goal is to extract key behavior or a hidden solution from the program.
- Examining the executable without running it.
- Using Ghidra's decompiler views and navigation tools to interpret machine code.
- Identifying important code paths and strings that reveal how the binary works.

### a) Install Ghidra

<br>
I already had Ghidra installed in my virtual machine.

<br>
<img width="764" height="570" alt="Screenshot 2026-02-07 at 22 22 13" src="https://github.com/user-attachments/assets/f914bfe5-4cee-407e-bafe-cc361db21006" />
<br>

### rever-C. Reverse engineer the packd binary to C language with Ghidra. Find the main program. Give variables descriptive names. Explain the program's operation. Solve the task from the binary, without the original source code. ezbin-challenges.zip

- In this task I will take a packed binary (compiled program, no source code) and use Ghidra to reverse engineer it.
- recover the main logic in C-like form.
- Rename variables so they make sense.
- Explain what the program does.
- Solve whatever task/challenge the binary contains.
<br>
I started by creating a new project: 

`File --> New Project --> Non-shared project --> named it: reverse-C-assignment`

<img width="750" height="554" alt="Screenshot 2026-02-07 at 22 31 20" src="https://github.com/user-attachments/assets/4d64eacf-808e-458f-b8cd-56f1a465a856" />
<br>
<br>
Import the bianry:
  
`File --> Import File--> packd --> OK --> Analyze now? --> YES`

<img width="706" height="630" alt="Screenshot 2026-02-07 at 22 51 48" src="https://github.com/user-attachments/assets/94a60fa5-223c-4acb-86ff-4f4254af4e5b" />
<br>
<br>
This error occured: 
<br>
<br>
<img width="914" height="535" alt="Screenshot 2026-02-07 at 22 57 37" src="https://github.com/user-attachments/assets/478b9322-63a4-43b5-a655-37832decea5c" />
<br>
This issue is because I am running on ARM64 (MacBook) and the native decomiler binary was not built. Without it Ghidra cannot show C code.
<br>
After being stuck for a while and making some reseraches,
<br>
I came across on how to build Ghidra's native decompiler, so I tried it:
<br>
I tried the following commands:

`sudo apt update`

`sudo apt install -y build-essential cmake ninja-build gcc g++ make`
<br>
This Installs compilers that Ghidra needs.

`cd /home/susu/Downloads/ghidra_12.0.2_PUBLIC`

`ls`

`cd support`

`ls`
<br>
and I was suppose to find `./buildNatives`but as you can see below, It was not there:
<br>

<img width="701" height="459" alt="Screenshot 2026-02-08 at 7 16 58" src="https://github.com/user-attachments/assets/4fc8a5aa-61a1-46a3-8f64-e17513a9ef8c" />

<br>

After finally getting my hands on another computer, I started the from the beggining.

<br>



<br>
I already had Ghidra installed in my virtual machine.
<br>
<br>
Succefully entered:

<br>

<img width="513" height="305" alt="Screenshot 2026-02-08 at 15 20 38" src="https://github.com/user-attachments/assets/088bca5a-aad5-4188-b363-f468990f8702" />

<br>
<br>

Renaming variables: 

<br>

<img width="509" height="346" alt="Screenshot 2026-02-08 at 15 21 40" src="https://github.com/user-attachments/assets/a8220b67-77d5-46e2-ae7e-90591890fca8" />

<br>

<img width="364" height="379" alt="Screenshot 2026-02-08 at 15 22 01" src="https://github.com/user-attachments/assets/0c2b44c2-2a5a-4b7a-bf5a-fce47833013a" />

<br>

What is happening: 
<br>

The program asks the user to enter a password. It reads the input and compares it with a hardcore password using strucmp. If the input matches the stored password, the program prints a success message and reveals the flag. Otherwise, it prints an error message.

<br>

The goal of this task is to analyze a compiled program (binary) using Ghidra and understand what it does. The program must be converted back into readable C code, variable names must be improved and the programs behaviour must be explained using only the binary file.

<br>

1.	How I started:
After opening the binary in Gidra and running the analysis, Ghidra found the main function automatically. All the program logic is inside this function. There are no other functions that check the password.

<br>

2.	 What the program does:
-	Asks the user to enter a password
-	Reads the input from the user
-	Compares the input with a password stored in the program
-	Prints the flag if the password is correct
-	Prints an error message if the password is wrong

<br>

3.	Reverse engineering C code
Below is a clean C version of the program. Only the variable names were changed to make the code easier to understand. The program works in the same way as the original binary:


<br>

<img width="295" height="304" alt="Screenshot 2026-02-08 at 15 27 51" src="https://github.com/user-attachments/assets/3fb658ea-1d70-43d2-a8e7-83a4ce3a4ed0" />

<br>

iVar1 was renamed to compare_result.
<br>
Input was changed to user_input.

<br>


4.	Explanation of the program
-	The program saves user’s input in user_input
-	It compares this input with the correct password using strcmp
-	If the result is 0, the password is correct and the flag is printed
-	If the result is not 0, the password is incorrect

<br>

5.	Solution
-	Password:piilos-AnAnAs
-	Flag: FLAG...

<br>

Both were found by analyzing the binary in Ghidra, without using the original source code.

<br>

### c) If backwards. Modify the passtr program's binary (without the original source code) so that it accepts all passwords except the correct one. Demonstrate with tests that the program works. ezbin-challenges.zip


started by making a copy of passtr so I don’t break it: 

<br>

<img width="425" height="59" alt="Screenshot 2026-02-08 at 15 30 50" src="https://github.com/user-attachments/assets/9aadc5cc-6b7f-4d92-bbe1-a562f5e15846" />

<br>


I went back to Ghidra, imported the passtr file and opened the decompile window of th main function:

<br>

<img width="241" height="243" alt="Screenshot 2026-02-08 at 15 31 26" src="https://github.com/user-attachments/assets/11fc28fc-fed1-488f-adf8-eaa8b2f98ca0" />

<br>

The key part from the decompiler is this: 

<br>

<img width="140" height="76" alt="Screenshot 2026-02-08 at 15 31 54" src="https://github.com/user-attachments/assets/6602cd85-4bd5-4ab1-ac8d-266232b37414" />

<br>

We want to flip the logic.

<br>

I single clicked the iVar1 and was able to see the listing window (in the left).

<br>

<img width="304" height="85" alt="Screenshot 2026-02-08 at 15 32 49" src="https://github.com/user-attachments/assets/f5c82e79-00a7-4c30-a299-987aa9ff4bb1" />

<br>

In the listing we can see:
<br>
Strcmp -->are   the two passwords the same?
<br>
TEST EAX, EAX -->   was the result zero or not?
<br>
JZN -->   Id the result is NOT zero, go somewhere else.

<br>

So right now if the password is wrong (not zero) it jumps to LAB_00101252.
<br>
We want the opposite. We want the jump to happen when the password is correct.
<br>
We need to change:  JNZ  -->  JZ
<br>
JZN --> Jump when the result is not zero
<br>
JZ --> Jump when the result is zero
<br>

How did I do this?
<br>
I right-clicked JZN --> path instructions --> assemble then a red box occurred and now I can modify it:

<br>

<img width="453" height="108" alt="Screenshot 2026-02-08 at 15 36 35" src="https://github.com/user-attachments/assets/db64dc8f-1f1b-4ddb-bcad-6c759a6b28f8" />

<br>

I changed JNZ to JZ:

<br>

<img width="443" height="44" alt="Screenshot 2026-02-08 at 15 37 08" src="https://github.com/user-attachments/assets/d457d8c6-612d-4f48-901b-8a8e5638fe3a" />


<br>

Now I have changed it to --> All wrong password --> accepted.

<br>

In the next step I saved the modified program: File --> export program --> Format: Original File --> output file: /home/selmaeu/passtr_patched.

<br>

<img width="510" height="299" alt="Screenshot 2026-02-08 at 15 38 32" src="https://github.com/user-attachments/assets/1e61c0f5-dafa-4d58-8044-ef83df788645" />

<br>

I went back to terminal and checked the file and modified the file to make it executable:

<br>

And run it  ./passtr_patched:

<br>

<img width="232" height="41" alt="Screenshot 2026-02-08 at 15 39 06" src="https://github.com/user-attachments/assets/2ed515e1-e141-4564-aac2-0e7940a4b0fa" />

<br>

### d) Nora CrackMe

<br>

In this task I need to download NoraCodes crackmes, compile them into binaries, then solve them by reverse engineering (not editing the files).

<br>

I started by installing everything I need:
<br>
sudo apt update
<br>
sudo apt install y- git build-essential
<br>

<img width="362" height="252" alt="Screenshot 2026-02-08 at 15 52 11" src="https://github.com/user-attachments/assets/4571000c-66b7-4f2f-af18-794226de860b" />

<br>


I downloaded the crackmes repo:

<br>


<img width="367" height="133" alt="Screenshot 2026-02-08 at 15 52 56" src="https://github.com/user-attachments/assets/4fce3a94-2a08-4d1e-a696-afa3202cdd58" />


<br>

In this step I complied one crackme into a binary. The README says that  make crackme01 will create a file named crackme01.

<br>

<img width="364" height="120" alt="Screenshot 2026-02-08 at 15 53 32" src="https://github.com/user-attachments/assets/a20981dc-04e8-4b7f-b546-acfaeb1eb6eb" />

<br>

### e) Nora crackme01

I started by running the crackme01:

<br>

<img width="288" height="21" alt="Screenshot 2026-02-08 at 15 54 35" src="https://github.com/user-attachments/assets/81d77005-99e5-45a3-8f94-5b34a821e061" />

<br>


This tells us that the program wants one input. 

<br>

Let’s test it by giving a random input: 

<br>


<img width="296" height="33" alt="Screenshot 2026-02-08 at 15 55 18" src="https://github.com/user-attachments/assets/2fd5f07b-b1b7-4eb7-a393-04ac22a648fe" />

<br>

As you can see above, the input was incorrect.
<br>

Now the task was to find the one argument that would be correct.
<br>
I used strings: 
<br>

<img width="347" height="15" alt="Screenshot 2026-02-08 at 15 56 02" src="https://github.com/user-attachments/assets/db15aa15-9f3e-4573-8549-e0b2e67fb6d6" />

<br>

<img width="152" height="51" alt="Screenshot 2026-02-08 at 15 56 19" src="https://github.com/user-attachments/assets/1c9451c1-236c-4a47-9eab-a6f5e93a4563" />

<br>

And the correct answer is “passwprd1”.

<br> 

Now let’s try it:

<br> 

<img width="349" height="41" alt="Screenshot 2026-02-08 at 15 56 53" src="https://github.com/user-attachments/assets/b26a2b2d-a352-4ce5-a490-60aea91d525b" />

<br> 

And it worked!!

<br> 

### Nora crackme01e

I started by making the crackme01e.64:

<br> 

<img width="333" height="142" alt="Screenshot 2026-02-08 at 15 57 45" src="https://github.com/user-attachments/assets/bff0602f-a69f-45d6-847e-3d4cba86508f" />

<br> 

I wanted to try this one with Ghidra so I opened the file there:

<br> 

<img width="255" height="367" alt="Screenshot 2026-02-08 at 15 58 29" src="https://github.com/user-attachments/assets/e1d8b4f5-3ec8-4b4c-996b-a719cc7f4ff4" />

<br> 

As you can see above the password is  slm!pass.k

<br> 

<img width="345" height="32" alt="Screenshot 2026-02-08 at 15 59 00" src="https://github.com/user-attachments/assets/fb605020-0620-4a03-81e5-75a13c789d82" />

<br> 

### Nora crackme02

Ghidra --> Fille --> Import File --> choose crackme02 and analyze it:

<br>  

Renaming the variables:

<br> 

<img width="418" height="337" alt="Screenshot 2026-02-08 at 16 00 29" src="https://github.com/user-attachments/assets/88056b17-dcbb-4cb6-a1c3-65afd3e366d1" />

<br> 

Argc --> number of command-line arguments
<br> 
Argv --> array of command-line arguments
<br> 
Input_char  --> current character from user input
<br> 
Expected_char  --> expected character used for input validation
<br> 
Index --> loop index for character comparison
<br> 
Return_code --> program exit status

<br> 


The program checks the input by comparing it to “password1” and makes sure each typed character comes just before the correct one, then prints success if it matches. 
<br> 
In the command you can see expected_char (reference to password1)
<br> 
expected_char -1 means one ASCII value less which means the password is o\`rrvnqc0
<br> 


<img width="352" height="30" alt="Screenshot 2026-02-08 at 16 02 09" src="https://github.com/user-attachments/assets/b93d5790-4194-419c-b09d-6884c34b9241" />

<br> 

### Sources:

https://terokarvinen.com/application-hacking/
<br> 
https://github.com/NoraCodes/crackmes



